// $Id: FetchIStream.pgcc,v 1.61 2005/10/05 08:49:27 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2001 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

// NOTE that this code might be duplicated for SQLite

#include <ManuProCConfig.h>
#ifndef MPC_SQLITE
#include <Misc/FetchIStream.h>
#include <Misc/SQLerror.h>
#include <Misc/itos.h>
#ifdef USE_PARAMETERS
#include <libpq-fe.h>
#include <Misc/pg_type.h>
#endif

exec sql include sqlca;

#ifdef OLD_ECPG
#define ECPGdo300
#else
#define ECPGdo300 0,1,
#endif

#define DEBUG_FIS(x) std::cerr << x << '\n'
// ,y...) x,##y

extern "C" {
extern PGresult **ECPGdescriptor_lvalue(int line, const char *descriptor);
}

#ifdef USE_PARAMETERS
#define ECPG_SQLSTATE_NO_DATA				"02000"
#define ECPG_SQLSTATE_USING_CLAUSE_DOES_NOT_MATCH_PARAMETERS	"07001"
#define ECPG_SQLSTATE_USING_CLAUSE_DOES_NOT_MATCH_TARGETS		"07002"
#define ECPG_SQLSTATE_RESTRICTED_DATA_TYPE_ATTRIBUTE_VIOLATION	"07006"
#define ECPG_SQLSTATE_INVALID_DESCRIPTOR_INDEX		"07009"
#define ECPG_SQLSTATE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION	"08001"
#define ECPG_SQLSTATE_CONNECTION_DOES_NOT_EXIST		"08003"
#define ECPG_SQLSTATE_TRANSACTION_RESOLUTION_UNKNOWN	"08007"
#define ECPG_SQLSTATE_CARDINALITY_VIOLATION "21000"
#define ECPG_SQLSTATE_NULL_VALUE_NO_INDICATOR_PARAMETER "22002"
#define ECPG_SQLSTATE_ACTIVE_SQL_TRANSACTION		"25001"
#define ECPG_SQLSTATE_NO_ACTIVE_SQL_TRANSACTION		"25P01"
#define ECPG_SQLSTATE_INVALID_SQL_STATEMENT_NAME	"26000"
#define ECPG_SQLSTATE_INVALID_SQL_DESCRIPTOR_NAME	"33000"
#define ECPG_SQLSTATE_INVALID_CURSOR_NAME	"34000"
#define ECPG_SQLSTATE_SYNTAX_ERROR			"42601"
#define ECPG_SQLSTATE_DATATYPE_MISMATCH		"42804"
#define ECPG_SQLSTATE_DUPLICATE_CURSOR		"42P03"

/* implementation-defined internal errors of ecpg */
#define ECPG_SQLSTATE_ECPG_INTERNAL_ERROR	"YE000"
#define ECPG_SQLSTATE_ECPG_OUT_OF_MEMORY	"YE001"
#endif

// ecpg incoming descriptor has to be FetchIStream

FetchIStream::FetchIStream(const std::string &descr, int line)
	: naechstesFeld(0), zeile(line), result(0)
{  PGresult **r=ECPGdescriptor_lvalue(__LINE__,descr.c_str());
   if (r) result=*r;
}

FetchIStream &FetchIStream::operator>>(std::string &str)
{  if (!result)
	mythrow(SQLerror(__FUNCTION__,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from (left?)"));
   if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror(__FUNCTION__,ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   if (PQgetisnull(result, zeile, naechstesFeld))
	mythrow(SQLerror(__FUNCTION__,ECPG_MISSING_INDICATOR,"missing indicator"));
   const char *pval = PQgetvalue(result, zeile, naechstesFeld);
   if (pval) str=pval;
   else str="";
   if (Query::debugging.on) 
      std::cerr << "FIS result["<<zeile<<','<<naechstesFeld<<"]="<<str << '\n';
   naechstesFeld++;
   return *this;
}

void FetchIStream::ThrowIfNotEmpty(const char *where)
{  if (!result)
	mythrow(SQLerror(where,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from"));
   if (naechstesFeld<PQnfields(result))
	mythrow(SQLerror(where,ECPG_TOO_FEW_ARGUMENTS,"too few arguments"));
}

int FetchIStream::getIndicator() const
{  if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror("FetchIStream::getIndicator",ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   return -PQgetisnull(result, zeile, naechstesFeld);
}

bool FetchIStream::good() const
{  return result && naechstesFeld<PQnfields(result); }

std::string FetchIStream::getFieldName() const
{  if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror("FetchIStream::getFieldName",ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   return PQfname(result,naechstesFeld);
}

/// QUERY

#ifdef USE_PARAMETERS
struct connection
{	char const *	name;
        PGconn *	connection;
        // ...
};

extern "C"
{
struct connection *ECPGget_connection(char const *name);
}

void Query::raise(std::string const& state, int code, std::string const& message, std::string const& detail)
{ memcpy(sqlca.sqlstate,state.c_str(),5);
  sqlca.sqlcode=code;
  error=code;
  strncpy(sqlca.sqlerrm.sqlerrmc, message.c_str(), sizeof(sqlca.sqlerrm.sqlerrmc));
  if (code!=ECPG_NOT_FOUND)
    Row::mythrow(SQLerror(query,detail.empty()?message:detail));
}

void Query::raise(char const* state, int code, char const* message, char const* detail)
{ if (!state) state=ECPG_SQLSTATE_ECPG_INTERNAL_ERROR;
  if (!message) message="internal error";
  if (!detail) detail="";
  raise(std::string(state),code,message,detail);
}
#endif

// note cursor is the name for both the cursor and the descriptor
void Query::Execute() throw(SQLerror)
{
   time_t start=-1;
   if (debugging.time_queries) start=time(0);
#ifndef USE_PARAMETERS
   exec sql begin declare section;
   char *COMMAND=const_cast<char*>(query.c_str());
   exec sql end declare section;

   eof=false;
//   exec sql allocate descriptor X;
sqlca.sqlcode=0;
   ECPGallocate_desc(__LINE__, descriptor.c_str());
   if (sqlca.sqlcode) { DEBUG_FIS(SQLerror("allocate descriptor")); eof=true; }
//   exec sql prepare com from :COMMAND;
//   exec sql execute com into descriptor X;
#ifdef MPC_ECPG_PREPARE
   ECPGprepare(__LINE__, "com" , COMMAND);
   ECPGdo(__LINE__, 0, 1, NULL, "?",
	ECPGt_char_variable,ECPGprepared_statement("com"),1L,1L,sizeof(char),
	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
	ECPGt_descriptor, descriptor.c_str(), 0L, 0L, 0L,
	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#else
   ECPGdo(__LINE__, ECPGdo300 NULL, COMMAND, 
   	ECPGt_EOIT,
   	ECPGt_descriptor, descriptor.c_str(), 0L, 0L, 0L,
   	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#endif
   error=sqlca.sqlcode;
   lines=sqlca.sqlerrd[2];
   
   if (sqlca.sqlcode && sqlca.sqlcode!=100)
   {  eof=true;
#ifdef OLD_ECPG   
      FetchIStream::mythrow(SQLerror(query)); 
#else
      PGresult *lresult=*(ECPGdescriptor_lvalue(__LINE__,descriptor.c_str()));
      std::string detail;
      if (lresult && PQresultErrorField(lresult,PG_DIAG_MESSAGE_DETAIL)) 
        detail=PQresultErrorField(lresult,PG_DIAG_MESSAGE_DETAIL);
//      Message(lresult);
      FetchIStream::mythrow(SQLerror(query,detail)); 
#endif
   }
   else if (sqlca.sqlcode==100 && Query::debugging.on)
   {  DEBUG_FIS("no lines returned/changed");
   }
   result=*(ECPGdescriptor_lvalue(__LINE__,descriptor.c_str()));
#else // query parameters (using libpq)
  PGconn *conn=ECPGget_connection(NULL)->connection;
  eof=false;
  sqlca.sqlcode=0;
  int numparams=params.size();
  int binary[params.size()];
  Oid types[params.size()];
  char const * values[params.size()];
  int length[params.size()];
//  memset(binary,0,sizeof(binary));
  if (Query::debugging.on)
    std::cerr << "Query " << query << "\n"
      "with params: ";
  unsigned idx=0;
  for (ArgumentList::const_iterator i=params.begin();i!=params.end();++i,++idx)
  { if (params.type_of(i)==VOIDOID)
    { values[idx]=0;
      length[idx]=0;
      types[idx]=TEXTOID; // or INT4OID ?, gibt sonst "-400 konnte Datentyp von Parameter $2 nicht ermitteln"
      binary[idx]=false;
      if (Query::debugging.on) std::cerr << "<NULL>,";
    }
    else
    { values[idx]=i->c_str();
      length[idx]=i->size();
      types[idx]=params.type_of(i);
      binary[idx]=false;
      if (Query::debugging.on) std::cerr << *i << ",";
    }
  }
  if (Query::debugging.on) std::cerr << "\n";
  // oder PQsendPrepare PQsendQueryPrepared PQgetResult
  result=PQexecParams(conn,query.c_str(),numparams,types,values,length,binary,0);
  if (!result) raise(ECPG_SQLSTATE_ECPG_INTERNAL_ERROR,ECPG_PGSQL,PQerrorMessage(conn));
  if (Query::debugging.on) std::cerr << "result "<< PQresultStatus(result) << " " << PQcmdStatus(result) << "\n";
  // this resembles the code in ecpglib/execute.c
  switch (PQresultStatus(result))
  { case PGRES_TUPLES_OK:
      error=0;
      lines=PQntuples(result);
      eof=false;
      if (!lines) 
        raise(ECPG_SQLSTATE_NO_DATA, ECPG_NOT_FOUND, "no lines selected");
      break;
    case PGRES_EMPTY_QUERY:
      raise(ECPG_SQLSTATE_ECPG_INTERNAL_ERROR,ECPG_EMPTY,"empty query");
    case PGRES_COMMAND_OK:
      sqlca.sqlerrd[1] = PQoidValue(result);
      lines = sqlca.sqlerrd[2] = atol(PQcmdTuples(result));
      if (!lines &&
		(!strncmp(PQcmdStatus(result), "UPDATE", 6)
		|| !strncmp(PQcmdStatus(result), "INSERT", 6)
		|| !strncmp(PQcmdStatus(result), "DELETE", 6)))
	raise(ECPG_SQLSTATE_NO_DATA, ECPG_NOT_FOUND, "no lines affected");
      eof=true;
      break;
    case PGRES_COPY_OUT:
    case PGRES_COPY_IN:
      PQendcopy(conn);
      eof=true;
      break;
    case PGRES_NONFATAL_ERROR:
    case PGRES_FATAL_ERROR:
    case PGRES_BAD_RESPONSE:
    default:
      raise(PQresultErrorField(result, PG_DIAG_SQLSTATE), ECPG_PGSQL, 
          PQresultErrorField(result, PG_DIAG_MESSAGE_PRIMARY),
          PQresultErrorField(result,PG_DIAG_MESSAGE_DETAIL));
      break;
  }
  PGnotify *notify = PQnotifies(conn);
  if (notify)
  { PQfreemem(notify);
  }
#endif
  if (debugging.time_queries && (time(0)-start)>4)
  { std::cerr << (time(0)-start) << " secs: " << query << '\n';
  }
}

// note cursor is the name for both the cursor and the descriptor
Query::Query(const std::string &command)
: descriptor(std::string("Query")+ulltos(reinterpret_cast<unsigned long long>(this))), 
	eof(true), line(), result(), query(command), num_params(), 
	error(ECPG_TOO_FEW_ARGUMENTS), lines()
{  const char *p=query.c_str();
   while ((p=ArgumentList::next_insert(p))) { ++num_params; ++p; }
   params.setNeededParams(num_params);
   Execute_if_complete();
}

Query::~Query()
{  if (!params.complete())
   {  std::cerr << "The query " << query << " still needed " 
   	<< params.HowManyNeededParams() 
   	<< " parameters on destruction and got never executed!\n";
      if (Query::debugging.on)
      {  std::cerr << "existing parameters: ";
         for (ArgumentList::const_iterator i=params.begin();i!=params.end();
			++i)
            std::cerr << *i << ',';
         std::cerr << '\n';
      }
      sqlca.sqlcode=ECPG_TOO_FEW_ARGUMENTS;
   }
   else
   {  
#ifndef USE_PARAMETERS
#ifdef OLD_ECPG
      struct sqlca copy=sqlca;
#else
      struct sqlca_t copy=sqlca;
#endif      
      //   exec sql deallocate descriptor X;
      ECPGdeallocate_desc(__LINE__, descriptor.c_str());
      // do not change sqlca ... believe me, you don't want to
      sqlca=copy;
#else
      PQclear(result);
      result=0;
#endif
   }
}

void Query::Fetch(FetchIStream &is)
{  if (!params.complete())
      FetchIStream::mythrow(SQLerror(query,ECPG_TOO_FEW_ARGUMENTS,"to few input parameter"));
   if (!eof)
   {  if (line<PQntuples(result)) 
      {  is=FetchIStream(result,line++);
         return;
      }
      eof=true;
   }
 is=FetchIStream();
}

void Query::Execute(const std::string &command) throw(SQLerror)
{  exec sql begin declare section;
   char *COMMAND=const_cast<char*>(command.c_str());
   exec sql end declare section;

   exec sql execute immediate :COMMAND;
}

int Query::Code() {  
	return sqlca.sqlcode; 
}

unsigned Query::Lines() { 
	return sqlca.sqlerrd[2]; 
}

#include <internal/libpq-int.h>

void FetchIStream::Fake::init()
{  PGresult *res=PQmakeEmptyPGresult(0,PGRES_TUPLES_OK);
   res->ntups=1;
   res->numAttributes=1;
   res->attDescs=(PGresAttDesc*)calloc(1,sizeof(PGresAttDesc));
   res->attDescs->name="col";
   res->attDescs->typid=25;
   res->attDescs->typlen=0;
   res->attDescs->atttypmod=0;
   res->tuples=(PGresAttValue**)calloc(1,sizeof(PGresAttValue*));
   res->tuples[0]=(PGresAttValue*)calloc(1,sizeof(PGresAttValue));
   res->tuples[0][0].len=NULL_LEN;   
   res->tupArrSize=1;
   res->binary=false;
   result=res;
}

FetchIStream::Fake::Fake(const std::string &val) : value(val)
{  init();
   const_cast<PGresult*>(result)->tuples[0][0].len=value.size();
   const_cast<PGresult*>(result)->tuples[0][0].value=
		const_cast<char*>(value.c_str());
}

FetchIStream::Fake::Fake(const Fake &a) : value(a.value)
{  init();
   if (a.result->tuples[0][0].value)
   { const_cast<PGresult*>(result)->tuples[0][0].len=value.size();
     const_cast<PGresult*>(result)->tuples[0][0].value=
		const_cast<char*>(value.c_str());
   }
}

FetchIStream::Fake::~Fake()
{  if (result) 
   { free(result->attDescs);
     free(result->tuples[0]);
     PQclear(const_cast<PGresult*>(result));
   }
}
#endif
