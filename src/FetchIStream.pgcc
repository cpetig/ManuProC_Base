// $Id: FetchIStream.pgcc,v 1.57 2005/09/14 12:14:46 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2001 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

// NOTE that this code might be duplicated for SQLite

#include <ManuProCConfig.h>
#ifndef MPC_SQLITE
#include <Misc/FetchIStream.h>
#include <Misc/SQLerror.h>
#include <Misc/itos.h>

exec sql include sqlca;

#ifdef OLD_ECPG
#define ECPGdo300
#else
#define ECPGdo300 0,1,
#endif

#define DEBUG_FIS(x) std::cerr << x << '\n'
// ,y...) x,##y

extern "C" {
extern PGresult **ECPGdescriptor_lvalue(int line, const char *descriptor);
}

// ecpg incoming descriptor has to be FetchIStream

FetchIStream::FetchIStream(const std::string &descr, int line)
	: naechstesFeld(0), zeile(line), result(0)
{  PGresult **r=ECPGdescriptor_lvalue(__LINE__,descr.c_str());
   if (r) result=*r;
}

FetchIStream &FetchIStream::operator>>(std::string &str)
{  if (!result)
	mythrow(SQLerror(__FUNCTION__,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from (left?)"));
   if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror(__FUNCTION__,ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   if (PQgetisnull(result, zeile, naechstesFeld))
	mythrow(SQLerror(__FUNCTION__,ECPG_MISSING_INDICATOR,"missing indicator"));
   const char *pval = PQgetvalue(result, zeile, naechstesFeld);
   if (pval) str=pval;
   else str="";
   if (Query::debugging.on) 
      std::cerr << "FIS result["<<zeile<<','<<naechstesFeld<<"]="<<str << '\n';
   naechstesFeld++;
   return *this;
}

void FetchIStream::ThrowIfNotEmpty(const char *where)
{  if (!result)
	mythrow(SQLerror(where,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from"));
   if (naechstesFeld<PQnfields(result))
	mythrow(SQLerror(where,ECPG_TOO_FEW_ARGUMENTS,"too few arguments"));
}

int FetchIStream::getIndicator() const
{  if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror("FetchIStream::getIndicator",ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   return -PQgetisnull(result, zeile, naechstesFeld);
}

bool FetchIStream::good() const
{  return result && naechstesFeld<PQnfields(result); }

std::string FetchIStream::getFieldName() const
{  if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror("FetchIStream::getFieldName",ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   return PQfname(result,naechstesFeld);
}

/// QUERY

// note cursor is the name for both the cursor and the descriptor
void Query::Execute() throw(SQLerror)
{  exec sql begin declare section;
   char *COMMAND=const_cast<char*>(query.c_str());
   exec sql end declare section;

   eof=false;
//   exec sql allocate descriptor X;
sqlca.sqlcode=0;
   ECPGallocate_desc(__LINE__, descriptor.c_str());
   if (sqlca.sqlcode) { DEBUG_FIS(SQLerror("allocate descriptor")); eof=true; }
//   exec sql prepare com from :COMMAND;
//   exec sql execute com into descriptor X;
#ifdef MPC_ECPG_PREPARE
   ECPGprepare(__LINE__, "com" , COMMAND);
   ECPGdo(__LINE__, 0, 1, NULL, "?",
	ECPGt_char_variable,ECPGprepared_statement("com"),1L,1L,sizeof(char),
	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
	ECPGt_descriptor, descriptor.c_str(), 0L, 0L, 0L,
	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#else
   ECPGdo(__LINE__, ECPGdo300 NULL, COMMAND, 
   	ECPGt_EOIT,
   	ECPGt_descriptor, descriptor.c_str(), 0L, 0L, 0L,
   	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#endif
   error=sqlca.sqlcode;
   lines=sqlca.sqlerrd[2];
   
   if (sqlca.sqlcode && sqlca.sqlcode!=100)
   {  eof=true;
#ifdef OLD_ECPG   
      FetchIStream::mythrow(SQLerror(query)); 
#else
      PGresult *lresult=*(ECPGdescriptor_lvalue(__LINE__,descriptor.c_str()));
      std::string detail;
      if (lresult && PQresultErrorField(lresult,PG_DIAG_MESSAGE_DETAIL)) 
        detail=PQresultErrorField(lresult,PG_DIAG_MESSAGE_DETAIL);
//      Message(lresult);
      FetchIStream::mythrow(SQLerror(query,detail)); 
#endif
   }
   else if (sqlca.sqlcode==100 && Query::debugging.on)
   {  DEBUG_FIS("no lines returned/changed");
   }
   result=*(ECPGdescriptor_lvalue(__LINE__,descriptor.c_str()));
}

// note cursor is the name for both the cursor and the descriptor
Query::Query(const std::string &command)
: descriptor(std::string("Query")+ulltos(reinterpret_cast<unsigned long long>(this))), 
	eof(true), line(), result(), query(command), num_params(), 
	error(ECPG_TOO_FEW_ARGUMENTS), lines()
{  const char *p=query.c_str();
   while ((p=ArgumentList::next_insert(p))) { ++num_params; ++p; }
   params.setNeededParams(num_params);
   Execute_if_complete();
}

Query::~Query()
{  if (!params.complete())
   {  std::cerr << "The query " << query << " still needed " 
   	<< params.HowManyNeededParams() 
   	<< " parameters on destruction and got never executed!\n";
      if (Query::debugging.on)
      {  std::cerr << "existing parameters: ";
         for (ArgumentList::const_iterator i=params.begin();i!=params.end();
			++i)
            std::cerr << *i << ',';
         std::cerr << '\n';
      }
      sqlca.sqlcode=ECPG_TOO_FEW_ARGUMENTS;
   }
   else
   {  
#ifdef OLD_ECPG
      struct sqlca copy=sqlca;
#else
      struct sqlca_t copy=sqlca;
#endif      
      //   exec sql deallocate descriptor X;
      ECPGdeallocate_desc(__LINE__, descriptor.c_str());
      // do not change sqlca ... believe me, you don't want to
      sqlca=copy;
   }
}

void Query::Fetch(FetchIStream &is)
{  if (!params.complete())
      FetchIStream::mythrow(SQLerror(query,ECPG_TOO_FEW_ARGUMENTS,"to few input parameter"));
   if (!eof)
   {  if (line<PQntuples(result)) 
      {  is=FetchIStream(result,line++);
         return;
      }
      eof=true;
   }
 is=FetchIStream();
}

void Query::Execute(const std::string &command) throw(SQLerror)
{  exec sql begin declare section;
   char *COMMAND=const_cast<char*>(command.c_str());
   exec sql end declare section;

   exec sql execute immediate :COMMAND;
}

int Query::Code() {  
	return sqlca.sqlcode; 
}

unsigned Query::Lines() { 
	return sqlca.sqlerrd[2]; 
}

#include <internal/libpq-int.h>

void FetchIStream::Fake::init()
{  PGresult *res=PQmakeEmptyPGresult(0,PGRES_TUPLES_OK);
   res->ntups=1;
   res->numAttributes=1;
   res->attDescs=(PGresAttDesc*)calloc(1,sizeof(PGresAttDesc));
   res->attDescs->name="col";
   res->attDescs->typid=25;
   res->attDescs->typlen=0;
   res->attDescs->atttypmod=0;
   res->tuples=(PGresAttValue**)calloc(1,sizeof(PGresAttValue*));
   res->tuples[0]=(PGresAttValue*)calloc(1,sizeof(PGresAttValue));
   res->tuples[0][0].len=NULL_LEN;   
   res->tupArrSize=1;
   res->binary=false;
   result=res;
}

FetchIStream::Fake::Fake(const std::string &val) : value(val)
{  init();
   const_cast<PGresult*>(result)->tuples[0][0].len=value.size();
   const_cast<PGresult*>(result)->tuples[0][0].value=
		const_cast<char*>(value.c_str());
}

FetchIStream::Fake::Fake(const Fake &a) : value(a.value)
{  init();
   if (a.result->tuples[0][0].value)
   { const_cast<PGresult*>(result)->tuples[0][0].len=value.size();
     const_cast<PGresult*>(result)->tuples[0][0].value=
		const_cast<char*>(value.c_str());
   }
}

FetchIStream::Fake::~Fake()
{  if (result) 
   { free(result->attDescs);
     free(result->tuples[0]);
     PQclear(const_cast<PGresult*>(result));
   }
}
#endif
